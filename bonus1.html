<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Corporate Escape - The 9-to-5 Boss Battle</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap');
        
        /* ===== RESET & BASE STYLES ===== */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            background: linear-gradient(135deg, #0f0c29, #302b63, #24243e);
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            font-family: 'Press Start 2P', cursive;
            overflow: hidden;
            touch-action: none;
            position: relative;
        }
        
        /* ===== GAME CONTAINER ===== */
        #gameWrapper {
            width: 100vw;
            height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            flex-direction: column;
        }
        
        #gameContainer {
            width: min(900px, 96vw);
            height: min(500px, 60vh);
            background: linear-gradient(to bottom, #ff6b9d 0%, #c44569 50%, #feca57 100%);
            position: relative;
            overflow: hidden;
            border: 4px solid #00ff41;
            box-shadow: 0 0 30px rgba(0, 255, 65, 0.5);
            border-radius: 8px;
        }
        
        /* Hide fullscreen button */
        #gameContainer::-webkit-media-controls-fullscreen-button {
            display: none !important;
        }
        
        #gameContainer::--webkit-media-controls {
            display: none !important;
        }
        
        video::-webkit-media-controls-fullscreen-button {
            display: none;
        }
        
        /* ===== GAME FLOOR ===== */
        .floor {
            position: absolute;
            bottom: 0;
            left: 0;
            width: 100%;
            height: 50px;
            background: repeating-linear-gradient(
                90deg,
                #2c3e50 0px,
                #2c3e50 20px,
                #34495e 20px,
                #34495e 40px
            );
            border-top: 3px solid #000;
        }
        
        /* ===== PLAYER ===== */
        #player {
            width: 50px;
            height: 50px;
            position: absolute;
            bottom: 50px;
            left: 100px;
            font-size: 40px;
            z-index: 100;
            filter: drop-shadow(3px 3px 0px rgba(0, 0, 0, 0.5));
            transition: transform 0.1s ease-out;
            user-select: none;
        }
        
        .player-jumping {
            transform: rotate(-15deg) scale(1.1);
        }
        
        .player-invulnerable {
            animation: blink 0.2s steps(2, start) infinite;
        }
        
        @keyframes blink {
            50% { opacity: 0.3; }
        }
        
        /* ===== OBSTACLES ===== */
        .obstacle {
            position: absolute;
            bottom: 50px;
            z-index: 50;
            filter: drop-shadow(2px 2px 0px rgba(0, 0, 0, 0.4));
            user-select: none;
            pointer-events: none;
        }
        
        .building {
            width: 70px;
            background: linear-gradient(to top, #2c3e50, #34495e, #4a5568);
            border: 3px solid #1a1a1a;
            border-bottom: none;
            position: absolute;
            bottom: 0 !important;
        }
        
        .building::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: repeating-linear-gradient(
                0deg,
                transparent 0px,
                transparent 12px,
                rgba(0, 0, 0, 0.2) 12px,
                rgba(0, 0, 0, 0.2) 15px
            );
        }
        
        .building::after {
            content: 'üè¢';
            position: absolute;
            top: 8px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 24px;
        }
        
        .enemy {
            font-size: 32px;
            animation: enemyFloat 1.5s ease-in-out infinite;
        }
        
        @keyframes enemyFloat {
            0%, 100% { transform: translateY(0px); }
            50% { transform: translateY(-8px); }
        }
        
        .karen::before { content: 'üë©‚Äçüíº'; }
        .karen::after {
            content: 'üí¢';
            position: absolute;
            top: -12px;
            right: -12px;
            font-size: 16px;
            animation: pulse 0.8s infinite;
        }
        
        .email::before { content: 'üìß'; }
        .email::after {
            content: 'üî•';
            position: absolute;
            top: -10px;
            right: -10px;
            font-size: 18px;
            animation: flicker 0.6s infinite;
        }
        
        .meeting::before { content: 'üìÖ'; }
        .meeting::after {
            content: 'URGENT';
            position: absolute;
            top: -18px;
            left: -8px;
            font-size: 6px;
            color: #fff;
            background: #ff0000;
            padding: 2px 4px;
            border-radius: 2px;
        }
        
        @keyframes pulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.3); }
        }
        
        @keyframes flicker {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }
        
        /* ===== COLLECTIBLES ===== */
        .collectible {
            font-size: 28px;
            animation: collectibleFloat 2s ease-in-out infinite;
            z-index: 60;
        }
        
        @keyframes collectibleFloat {
            0%, 100% { transform: translateY(0px) rotate(0deg); }
            50% { transform: translateY(-12px) rotate(10deg); }
        }
        
        .coffee::before { content: '‚òï'; }
        .vacation::before { content: 'üèñÔ∏è'; }
        .raise::before { content: 'üí∞'; }
        
        .collectible::after {
            content: '‚ú®';
            position: absolute;
            font-size: 14px;
            animation: sparkle 1s infinite;
        }
        
        @keyframes sparkle {
            0%, 100% { opacity: 0; transform: scale(0.5); }
            50% { opacity: 1; transform: scale(1.2); }
        }
        
        /* ===== BOSS ===== */
        .boss {
            font-size: 64px;
            animation: bossShake 0.3s ease-in-out infinite, bossGlow 1.5s ease-in-out infinite;
        }
        
        .boss::before { 
            content: 'üìÖ';
            color: #ff4500;
        }
        
        .boss::after {
            content: 'ALL-HANDS';
            position: absolute;
            top: -24px;
            left: -12px;
            font-size: 8px;
            color: #fff;
            background: linear-gradient(45deg, #ff0000, #ff4500);
            padding: 4px 6px;
            border-radius: 3px;
            box-shadow: 0 0 10px rgba(255, 0, 0, 0.8);
        }
        
        @keyframes bossShake {
            0%, 100% { transform: translateX(0) translateY(0); }
            25% { transform: translateX(-3px) translateY(-2px); }
            50% { transform: translateX(3px) translateY(2px); }
            75% { transform: translateX(-2px) translateY(1px); }
        }
        
        @keyframes bossGlow {
            0%, 100% { filter: drop-shadow(0 0 10px #ff4500); }
            50% { filter: drop-shadow(0 0 20px #ff0000); }
        }
        
        /* ===== PARTICLES ===== */
        .particle {
            position: absolute;
            width: 6px;
            height: 6px;
            border-radius: 50%;
            pointer-events: none;
            z-index: 200;
        }
        
        .particle-collect {
            background: #ffd700;
            animation: particleCollect 0.8s ease-out forwards;
        }
        
        .particle-hit {
            background: #ff4757;
            animation: particleHit 0.6s ease-out forwards;
        }
        
        @keyframes particleCollect {
            0% {
                opacity: 1;
                transform: translate(0, 0) scale(1);
            }
            100% {
                opacity: 0;
                transform: translate(var(--dx), var(--dy)) scale(0);
            }
        }
        
        @keyframes particleHit {
            0% {
                opacity: 1;
                transform: translate(0, 0) scale(1);
            }
            100% {
                opacity: 0;
                transform: translate(var(--dx), var(--dy)) scale(0.3);
            }
        }
        
        /* ===== HUD ===== */
        #hud {
            position: absolute;
            top: 15px;
            left: 15px;
            color: #00ff41;
            font-size: 10px;
            z-index: 150;
            text-shadow: 2px 2px 0px #000;
            background: rgba(0, 0, 0, 0.8);
            padding: 12px;
            border-radius: 6px;
            border: 2px solid #00ff41;
            line-height: 1.6;
        }
        
        #hud > div {
            margin: 4px 0;
        }
        
        
        .hud-value {
            color: #ffd700;
        }
        
        #progressBar {
            width: 150px;
            height: 12px;
            background: rgba(0, 0, 0, 0.5);
            border: 1px solid #00ff41;
            border-radius: 3px;
            margin-top: 6px;
            overflow: hidden;
        }
        
        #progressFill {
            height: 100%;
            background: linear-gradient(90deg, #00ff41, #ffd700);
            width: 0%;
            transition: width 0.3s ease-out;
        }
        
        /* ===== MENUS ===== */
        .menu {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: linear-gradient(135deg, #1a1a2e, #16213e);
            color: #00ff41;
            padding: 30px;
            padding-bottom: 40px;
            text-align: center;
            display: none;
            border: 3px solid #00ff41;
            border-radius: 12px;
            box-shadow: 0 0 40px rgba(0, 255, 65, 0.6);
            z-index: 300;
            max-width: 90%;
            max-height: 85vh;
            overflow-y: auto;
        }
        
        .menu h2 {
            color: #ff6b9d;
            margin-bottom: 20px;
            font-size: 18px;
            text-shadow: 2px 2px 0px #000;
        }
        
        .menu p {
            margin: 6px 0;
            font-size: 9px;
            line-height: 1.4;
            color: #fff;
        }
        
        .menu-button {
            background: linear-gradient(135deg, #00ff41, #00cc33);
            color: #000;
            border: none;
            padding: 12px 24px;
            font-family: 'Press Start 2P', cursive;
            font-size: 9px;
            cursor: pointer;
            margin: 8px;
            margin-top: 20px;
            border-radius: 6px;
            transition: all 0.2s ease;
            box-shadow: 0 4px 0 #006622;
        }
        
        .menu-button:hover {
            background: linear-gradient(135deg, #fff, #00ff41);
            transform: translateY(-2px);
            box-shadow: 0 6px 0 #006622;
        }
        
        .menu-button:active {
            transform: translateY(2px);
            box-shadow: 0 2px 0 #006622;
        }
        
        .menu-button.secondary {
            background: linear-gradient(135deg, #ff6b9d, #c44569);
            box-shadow: 0 4px 0 #8b2e4a;
        }
        
        .menu-button.secondary:hover {
            background: linear-gradient(135deg, #ff8fb3, #ff6b9d);
            box-shadow: 0 6px 0 #8b2e4a;
        }
        
        .menu-button.secondary:active {
            box-shadow: 0 2px 0 #8b2e4a;
        }
        
        /* ===== CONTROLS DISPLAY ===== */
        .control-group {
            margin: 10px 0;
            padding: 8px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 6px;
        }
        
        .control-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin: 5px 0;
            padding: 2px 0;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        .control-row:last-child {
            border-bottom: none;
        }
        
        .control-key {
            background: #2c3e50;
            color: #00ff41;
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 7px;
            border: 1px solid #00ff41;
            white-space: nowrap;
        }
        
        /* ===== PAUSE INDICATOR ===== */
        #pauseIndicator {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #ff6b9d;
            font-size: 64px;
            display: none;
            z-index: 250;
            text-shadow: 3px 3px 0px #000;
            animation: pausePulse 1.5s ease-in-out infinite;
        }
        
        @keyframes pausePulse {
            0%, 100% { 
                opacity: 0.8; 
                transform: translate(-50%, -50%) scale(1);
            }
            50% { 
                opacity: 1; 
                transform: translate(-50%, -50%) scale(1.1);
            }
        }
        
        /* ===== MOBILE CONTROLS ===== */
        #mobileControls {
            position: fixed;
            bottom: 20px;
            left: 0;
            right: 0;
            display: none;
            z-index: 400;
            pointer-events: none;
        }
        
        .jc {
            position: absolute;
            left: 30px;
            bottom: 0;
            width: 60px;
            height: 60px;
            background: rgba(0,50,0,.8);
            border: 2px solid #00ff41;
            border-radius: 50%;
            touch-action: none;
            cursor: pointer;
            pointer-events: all;
        }
        
        .js {
            position: absolute;
            width: 18px;
            height: 18px;
            background: #00ff41;
            border-radius: 50%;
            top: 50%;
            left: 50%;
            transform: translate(-50%,-50%);
            transition: none;
            box-shadow: 0 0 8px #00ff41;
            touch-action: none;
            pointer-events: none;
        }
        
        #mobileJumpBtn {
            position: absolute;
            right: 30px;
            bottom: 0;
            width: 100px;
            height: 100px;
            background: linear-gradient(135deg, #ff6b9d, #c44569);
            color: #fff;
            border: 3px solid #fff;
            border-radius: 50%;
            font-family: 'Press Start 2P', cursive;
            font-size: 11px;
            cursor: pointer;
            user-select: none;
            touch-action: manipulation;
            box-shadow: 0 6px 0 #8b2e4a, 0 0 20px rgba(255, 107, 157, 0.5);
            transition: all 0.1s;
            pointer-events: all;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        #mobileJumpBtn:active {
            transform: translateY(4px);
            box-shadow: 0 2px 0 #8b2e4a, 0 0 20px rgba(255, 107, 157, 0.5);
        }
        
        /* ===== WAVE INDICATOR ===== */
        #waveIndicator {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #ffd700;
            font-size: 32px;
            display: none;
            z-index: 250;
            text-shadow: 3px 3px 0px #000;
            background: rgba(0, 0, 0, 0.8);
            padding: 20px 40px;
            border-radius: 12px;
            border: 3px solid #ffd700;
            animation: waveAppear 0.5s ease-out;
        }
        
        @keyframes waveAppear {
            0% { 
                opacity: 0;
                transform: translate(-50%, -50%) scale(0.5);
            }
            100% { 
                opacity: 1;
                transform: translate(-50%, -50%) scale(1);
            }
        }
        
        /* ===== INSTRUCTIONS ===== */
        #instructions {
            position: absolute;
            top: 15px;
            right: 15px;
            color: #00ff41;
            font-size: 6px;
            text-align: right;
            text-shadow: 1px 1px 0px #000;
            background: rgba(0, 0, 0, 0.6);
            padding: 6px 10px;
            border-radius: 6px;
            border: 1px solid #00ff41;
            z-index: 100;
            line-height: 1.3;
            opacity: 0.5;
            transition: opacity 0.3s ease;
        }
        
        #instructions:hover {
            opacity: 1;
        }
        
        /* ===== RESPONSIVE DESIGN ===== */
        @media (max-width: 768px) {
            #gameContainer {
                width: 96vw;
                height: 55vh;
            }
            
            #mobileControls {
                display: block;
            }
            
            #instructions {
                display: none;
            }
            
            #hud {
                font-size: 8px;
                padding: 8px;
            }
            
            .menu {
                max-height: 85vh;
                max-width: 92%;
                padding: 18px;
                padding-bottom: 22px;
                top: 50%;
                transform: translate(-50%, -50%) scale(0.95);
                overflow-y: auto;
            }
            
            .menu h2 {
                font-size: 13px;
                margin-bottom: 10px;
            }
            
            .menu p {
                font-size: 8px;
                margin: 5px 0;
                line-height: 1.4;
            }
            
            .menu-button {
                font-size: 9px;
                padding: 10px 18px;
                margin-top: 10px;
            }
        }
        
        @media (max-width: 768px) and (max-height: 700px) {
            .menu {
                max-height: 82vh;
                padding: 16px;
                padding-bottom: 20px;
                transform: translate(-50%, -50%) scale(0.9);
            }
            
            .menu h2 {
                font-size: 12px;
                margin-bottom: 8px;
            }
            
            .menu p {
                font-size: 7px;
                margin: 4px 0;
            }
            
            .menu-button {
                font-size: 8px;
                padding: 9px 16px;
                margin-top: 8px;
            }
        }
        
        @media (max-width: 768px) and (max-height: 600px) {
            .menu {
                max-height: 78vh;
                padding: 14px;
                padding-bottom: 18px;
                transform: translate(-50%, -50%) scale(0.85);
            }
            
            .menu h2 {
                font-size: 11px;
                margin-bottom: 7px;
            }
            
            .menu p {
                font-size: 6px;
                margin: 3px 0;
            }
            
            .menu-button {
                font-size: 7px;
                padding: 8px 14px;
                margin-top: 7px;
            }
        }
        
        @media (max-height: 600px) {
            #gameContainer {
                height: 70vh;
            }
            
            #hud {
                font-size: 7px;
            }
        }
        
        @media (orientation: landscape) and (max-height: 500px) {
            #gameContainer {
                height: 85vh;
            }
            
            #mobileControls {
                bottom: 5px;
                padding: 5px;
            }
            
            #mobileJump {
                width: 100px;
                height: 50px;
                font-size: 9px;
            }
        }
    </style>
</head>
<body>
    <div id="gameWrapper">
        <div id="gameContainer">
            <!-- Floor -->
            <div class="floor"></div>
            
            <!-- HUD -->
            <div id="hud">
                <div>SCORE: <span class="hud-value" id="scoreValue">0</span></div>
                <div>LIVES: <span class="hud-value" id="livesValue">‚ù§Ô∏è‚ù§Ô∏è‚ù§Ô∏è</span></div>
                <div>WAVE: <span class="hud-value" id="waveValue">1</span></div>
                <div id="progressBar">
                    <div id="progressFill"></div>
                </div>
            </div>
            
            <!-- Player -->
            <div id="player">üèÉ‚Äç‚ôÇÔ∏è</div>
            
            <!-- Instructions -->
            <div id="instructions">
                WASD/ARROWS: MOVE<br>
                SPACE: JUMP | P: PAUSE | H: HELP
            </div>
            
            <!-- Pause Indicator -->
            <div id="pauseIndicator">‚è∏Ô∏è</div>
            
            <!-- Wave Indicator -->
            <div id="waveIndicator"></div>
            
            <!-- Pause Menu -->
            <div id="pauseMenu" class="menu">
                <h2>‚è∏Ô∏è GAME PAUSED</h2>
                <p>Take a breather from the corporate grind!</p>
                <button class="menu-button" onclick="game.togglePause()">RESUME</button>
                <button class="menu-button secondary" onclick="game.showControls()">CONTROLS</button>
                <button class="menu-button secondary" onclick="game.restart()">RESTART</button>
            </div>
            
            <!-- Controls Menu -->
            <div id="controlsMenu" class="menu">
                <h2>üéÆ HOW TO PLAY</h2>
                
                <div class="control-group">
                    <div class="control-row">
                        <span>Move Left:</span>
                        <span class="control-key">A / ‚Üê</span>
                    </div>
                    <div class="control-row">
                        <span>Move Right:</span>
                        <span class="control-key">D / ‚Üí</span>
                    </div>
                    <div class="control-row">
                        <span>Jump:</span>
                        <span class="control-key">W / ‚Üë / SPACE</span>
                    </div>
                    <div class="control-row">
                        <span>Duck:</span>
                        <span class="control-key">S / ‚Üì</span>
                    </div>
                    <div class="control-row">
                        <span>Pause:</span>
                        <span class="control-key">P / ESC</span>
                    </div>
                    <div class="control-row">
                        <span>Help:</span>
                        <span class="control-key">H</span>
                    </div>
                </div>
                
                <div class="control-group" style="margin-top: 10px;">
                    <p><strong>üéØ OBJECTIVE:</strong> Escape corporate hell!</p>
                    <p><strong>‚ùå AVOID:</strong> üë©‚Äçüíº Boss ‚Ä¢ üìß Email ‚Ä¢ üè¢ Buildings</p>
                    <p><strong>‚úÖ COLLECT:</strong> ‚òï Coffee ‚Ä¢ üèñÔ∏è Vacation ‚Ä¢ üí∞ Raise</p>
                </div>
                
                <div style="margin-top: 25px;">
                    <button class="menu-button" onclick="game.hideControls()">BACK</button>
                    <button class="menu-button" onclick="game.hideControls(); if(gameState.isRunning) game.togglePause(); else game.startFromMenu();">START GAME</button>
                </div>
            </div>
            
            <!-- Start Screen -->
            <div id="startScreen" class="menu" style="display: block;">
                <h2>üèÉ‚Äç‚ôÇÔ∏è CORPORATE ESCAPE üèÉ‚Äç‚ôÇÔ∏è</h2>
                <p style="font-size: 11px; margin: 15px 0;">ESCAPE THE 9-TO-5 GRIND!</p>
                <p>Survive waves of corporate nightmares</p>
                <p>Dodge angry bosses, urgent emails, and endless meetings!</p>
                <p id="startHighScore" style="margin-top: 15px;"></p>
                <button class="menu-button" onclick="game.startFromMenu()" style="font-size: 11px; padding: 15px 30px;">START GAME</button>
                <button class="menu-button secondary" onclick="game.showControlsFromStart()">HOW TO PLAY</button>
            </div>
            
            <!-- Game Over Menu -->
            <div id="gameOver" class="menu">
                <h2>üíÄ DEFEATED BY CAPITALISM! üíÄ</h2>
                <p>The corporate machine crushed your spirit!</p>
                <p><strong>Final Score:</strong> <span class="hud-value" id="finalScore">0</span></p>
                <p><strong>Wave Reached:</strong> <span class="hud-value" id="finalWave">1</span></p>
                <p id="highScoreDisplay"></p>
                <button class="menu-button" onclick="game.restart()">TRY AGAIN</button>
                <button class="menu-button secondary" onclick="game.showControls()">HOW TO PLAY</button>
            </div>
        </div>
        
        <!-- Mobile Controls -->
        <div id="mobileControls">
            <div id="mobileJoystick" class="jc">
                <div class="js joystick-stick"></div>
            </div>
            <button id="mobileJumpBtn">JUMP</button>
        </div>
    </div>

    <script>
        // =====================================================
        // GAME CONFIGURATION
        // =====================================================
        const CONFIG = {
            // Player settings
            player: {
                startX: 100,
                startY: 0,
                width: 50,
                height: 50,
                moveSpeed: 6,
                jumpPower: 18,
                gravity: 0.8,
                maxFallSpeed: 20
            },
            
            // Game mechanics
            game: {
                startLives: 3,
                invulnerabilityTime: 2000,
                waveScoreThreshold: 500,
                bossWave: 5
            },
            
            // Obstacle settings
            obstacles: {
                baseSpeed: 3,
                speedIncrement: 0.3,
                maxSpeed: 8,
                buildingMinHeight: 80,
                buildingMaxHeight: 140,
                buildingWidth: 70
            },
            
            // Spawn rates (in frames)
            spawn: {
                buildingMin: 180,
                buildingMax: 300,
                enemyMin: 120,
                enemyMax: 200,
                collectibleMin: 200,
                collectibleMax: 350
            },
            
            // Collision detection tolerance
            collision: {
                tolerance: 10
            },
            
            // Entity types
            enemies: [
                { class: 'karen', name: 'Angry Boss', damage: 1, points: 50 },
                { class: 'email', name: 'Urgent Email', damage: 1, points: 40 },
                { class: 'meeting', name: 'Emergency Meeting', damage: 1, points: 60 }
            ],
            
            collectibles: [
                { class: 'coffee', name: 'Coffee Break', points: 100 },
                { class: 'vacation', name: 'Vacation Day', points: 150 },
                { class: 'raise', name: 'Raise', points: 200 }
            ]
        };

        // =====================================================
        // GAME STATE MANAGER
        // =====================================================
        class GameState {
            constructor() {
                this.reset();
            }
            
            reset() {
                this.score = 0;
                this.lives = CONFIG.game.startLives;
                this.wave = 1;
                this.isRunning = false;
                this.isPaused = false;
                this.isInvulnerable = false;
                this.gameSpeed = 1;
                this.frameCount = 0;
                this.highScore = parseInt(localStorage.getItem('corporateEscapeHighScore')) || 0;
            }
            
            addScore(points) {
                this.score += points;
                this.checkWaveProgress();
                this.updateHighScore();
            }
            
            checkWaveProgress() {
                const newWave = Math.floor(this.score / CONFIG.game.waveScoreThreshold) + 1;
                if (newWave > this.wave) {
                    this.wave = newWave;
                    this.gameSpeed = 1 + (this.wave - 1) * 0.15;
                    game.showWaveIndicator();
                }
            }
            
            updateHighScore() {
                if (this.score > this.highScore) {
                    this.highScore = this.score;
                    localStorage.setItem('corporateEscapeHighScore', this.highScore);
                }
            }
            
            loseLife() {
                this.lives--;
                this.isInvulnerable = true;
                
                setTimeout(() => {
                    this.isInvulnerable = false;
                }, CONFIG.game.invulnerabilityTime);
                
                return this.lives <= 0;
            }
        }

        // =====================================================
        // PLAYER CLASS
        // =====================================================
        class Player {
            constructor() {
                this.element = document.getElementById('player');
                this.isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
                this.reset();
            }
            
            reset() {
                this.x = CONFIG.player.startX;
                this.y = CONFIG.player.startY;
                this.velocityY = 0;
                this.isJumping = false;
                this.isOnGround = true;
                this.isDucking = false;
                this.facingRight = true;
                this.emoji = 'üèÉ‚Äç‚ôÇÔ∏è';
                this.element.style.transform = 'scaleX(-1)'; // Start facing right (flipped)
                this.updateElement();
            }
            
            update() {
                // Apply gravity
                if (!this.isOnGround) {
                    this.velocityY -= CONFIG.player.gravity;
                    this.velocityY = Math.max(this.velocityY, -CONFIG.player.maxFallSpeed);
                    this.y += this.velocityY;
                }
                
                // Ground collision
                if (this.y <= 0) {
                    this.y = 0;
                    this.velocityY = 0;
                    this.isOnGround = true;
                    this.isJumping = false;
                    if (gameState.isRunning && !gameState.isPaused && !this.isDucking) {
                        this.emoji = 'üèÉ‚Äç‚ôÇÔ∏è';
                    }
                }
                
                this.updateElement();
            }
            
            jump() {
                if (this.isOnGround && !this.isJumping && !this.isDucking) {
                    this.velocityY = CONFIG.player.jumpPower;
                    this.isOnGround = false;
                    this.isJumping = true;
                    this.emoji = 'ü§∏‚Äç‚ôÇÔ∏è';
                    this.element.classList.add('player-jumping');
                }
            }
            
            moveLeft() {
                this.x = Math.max(10, this.x - CONFIG.player.moveSpeed);
                this.facingRight = false;
                if (!this.isJumping && !this.isDucking) {
                    this.emoji = 'üèÉ‚Äç‚ôÇÔ∏è';
                }
            }
            
            moveRight() {
                const maxX = game.containerWidth - CONFIG.player.width - 10;
                this.x = Math.min(maxX, this.x + CONFIG.player.moveSpeed);
                this.facingRight = true;
                if (!this.isJumping && !this.isDucking) {
                    this.emoji = 'üèÉ‚Äç‚ôÇÔ∏è';
                }
            }
            
            duck() {
                if (this.isOnGround && !this.isJumping) {
                    this.isDucking = true;
                    this.emoji = 'üßé‚Äç‚ôÇÔ∏è';
                    this.updateElement();
                }
            }
            
            stopDucking() {
                if (this.isDucking) {
                    this.isDucking = false;
                    if (gameState.isRunning && this.isOnGround) {
                        this.emoji = 'üèÉ‚Äç‚ôÇÔ∏è';
                        this.updateElement();
                    }
                }
            }
            
            takeDamage() {
                this.emoji = 'üòµ';
                this.element.classList.add('player-invulnerable');
                
                setTimeout(() => {
                    if (gameState.isRunning && gameState.lives > 0) {
                        this.emoji = 'üèÉ‚Äç‚ôÇÔ∏è';
                        this.element.classList.remove('player-invulnerable');
                        this.updateElement();
                    }
                }, CONFIG.game.invulnerabilityTime);
            }
            
            celebrate() {
                this.emoji = 'üòé';
                setTimeout(() => {
                    if (gameState.isRunning) {
                        this.emoji = 'üèÉ‚Äç‚ôÇÔ∏è';
                        this.updateElement();
                    }
                }, 500);
            }
            
            die() {
                this.emoji = 'üíÄ';
                this.element.classList.remove('player-jumping', 'player-invulnerable');
            }
            
            updateElement() {
                this.element.textContent = this.emoji;
                this.element.style.left = this.x + 'px';
                this.element.style.bottom = this.y + 'px';
                
                // Flip direction based on facing
                if (this.facingRight) {
                    this.element.style.transform = 'scaleX(-1)'; // Face right (flip)
                } else {
                    this.element.style.transform = 'scaleX(1)'; // Face left (normal)
                }
                
                if (!this.isJumping) {
                    this.element.classList.remove('player-jumping');
                }
            }
            
            getBounds() {
                const tolerance = CONFIG.collision.tolerance;
                
                if (this.isDucking) {
                    // When ducking, make hitbox much smaller
                    const duckHeight = CONFIG.player.height * 0.3; // Only 30% of normal height
                    const duckWidth = CONFIG.player.width * 0.7; // Slightly narrower too
                    const widthOffset = (CONFIG.player.width - duckWidth) / 2; // Center the narrower box
                    
                    return {
                        left: this.x + widthOffset + tolerance,
                        right: this.x + widthOffset + duckWidth - tolerance,
                        top: this.y + duckHeight - tolerance,
                        bottom: this.y + tolerance
                    };
                } else {
                    // Normal standing hitbox
                    return {
                        left: this.x + tolerance,
                        right: this.x + CONFIG.player.width - tolerance,
                        top: this.y + CONFIG.player.height - tolerance,
                        bottom: this.y + tolerance
                    };
                }
            }
        }

        // =====================================================
        // OBSTACLE CLASS
        // =====================================================
        class Obstacle {
            constructor(type, config) {
                this.type = type;
                this.config = config;
                this.element = this.createElement();
                this.x = game.containerWidth;
                this.speed = this.calculateSpeed();
                this.active = true;
            }
            
            createElement() {
                const el = document.createElement('div');
                el.className = `obstacle ${this.type} ${this.config.class}`;
                
                if (this.type === 'building') {
                    const height = Math.random() * 
                        (CONFIG.obstacles.buildingMaxHeight - CONFIG.obstacles.buildingMinHeight) + 
                        CONFIG.obstacles.buildingMinHeight;
                    el.style.height = height + 'px';
                    el.style.bottom = '0px'; // Force buildings to the ground
                    this.height = height;
                    this.width = CONFIG.obstacles.buildingWidth;
                    this.y = 0; // Buildings are on the ground
                } else {
                    // Enemies and collectibles
                    this.width = 50;
                    this.height = 50;
                    this.y = 0; // All at ground level for simplicity
                }
                
                game.container.appendChild(el);
                return el;
            }
            
            calculateSpeed() {
                const baseSpeed = CONFIG.obstacles.baseSpeed;
                const waveBonus = (gameState.wave - 1) * CONFIG.obstacles.speedIncrement;
                return Math.min(
                    baseSpeed + waveBonus,
                    CONFIG.obstacles.maxSpeed
                ) * gameState.gameSpeed;
            }
            
            update() {
                this.x -= this.speed;
                this.element.style.right = (game.containerWidth - this.x - this.width) + 'px';
                
                // Remove if off screen
                if (this.x + this.width < -50) {
                    this.destroy();
                    return false;
                }
                
                return true;
            }
            
            getBounds() {
                const tolerance = CONFIG.collision.tolerance;
                return {
                    left: this.x + tolerance,
                    right: this.x + this.width - tolerance,
                    top: this.y + this.height - tolerance,
                    bottom: this.y + tolerance
                };
            }
            
            destroy() {
                this.active = false;
                if (this.element.parentNode) {
                    this.element.remove();
                }
            }
        }

        // =====================================================
        // PARTICLE SYSTEM
        // =====================================================
        class ParticleSystem {
            createBurst(x, y, type = 'collect') {
                const particleCount = type === 'collect' ? 8 : 12;
                
                for (let i = 0; i < particleCount; i++) {
                    const particle = document.createElement('div');
                    particle.className = `particle particle-${type}`;
                    
                    const angle = (Math.PI * 2 * i) / particleCount;
                    const distance = 30 + Math.random() * 40;
                    const dx = Math.cos(angle) * distance;
                    const dy = Math.sin(angle) * distance;
                    
                    particle.style.setProperty('--dx', dx + 'px');
                    particle.style.setProperty('--dy', dy + 'px');
                    particle.style.left = x + 'px';
                    particle.style.bottom = y + 'px';
                    
                    game.container.appendChild(particle);
                    
                    setTimeout(() => {
                        if (particle.parentNode) {
                            particle.remove();
                        }
                    }, 800);
                }
            }
        }

        // =====================================================
        // INPUT HANDLER
        // =====================================================
        class InputHandler {
            constructor() {
                this.keys = {};
                this.joystickActive = false;
                this.joystickVector = {x: 0, y: 0};
                this.moveInterval = null;
                this.setupKeyboard();
                this.setupMobile();
            }
            
            setupKeyboard() {
                document.addEventListener('keydown', (e) => {
                    this.keys[e.key.toLowerCase()] = true;
                    
                    // Prevent default scrolling on arrow keys, space, and WASD
                    if (['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight', ' ', 'w', 'a', 's', 'd'].includes(e.key)) {
                        e.preventDefault();
                    }
                    
                    // Global shortcuts
                    if (e.key.toLowerCase() === 'p' || e.key === 'Escape') {
                        e.preventDefault();
                        if (gameState.isRunning) game.togglePause();
                        return;
                    }
                    
                    if (e.key.toLowerCase() === 'h') {
                        e.preventDefault();
                        if (gameState.isRunning) {
                            if (!gameState.isPaused) game.togglePause();
                            game.showControls();
                        }
                        return;
                    }
                    
                    // Game controls
                    if (!gameState.isRunning || gameState.isPaused) return;
                    
                    switch(e.key.toLowerCase()) {
                        case 'w':
                        case 'arrowup':
                        case ' ':
                            e.preventDefault();
                            player.jump();
                            break;
                    }
                });
                
                document.addEventListener('keyup', (e) => {
                    this.keys[e.key.toLowerCase()] = false;
                });
            }
            
            handleContinuousInput() {
                if (!gameState.isRunning || gameState.isPaused) return;
                
                // Keyboard controls only
                if (this.keys['a'] || this.keys['arrowleft']) {
                    player.moveLeft();
                }
                if (this.keys['d'] || this.keys['arrowright']) {
                    player.moveRight();
                }
                if (this.keys['s'] || this.keys['arrowdown']) {
                    player.duck();
                } else {
                    player.stopDucking();
                }
            }
            
            setupMobile(){
                const jc=document.getElementById('mobileJoystick');
                const js=document.querySelector('.js');
                const jumpBtn=document.getElementById('mobileJumpBtn');
                
                if(!jc || !js || !jumpBtn){
                    console.log('Mobile controls not found');
                    return;
                }
                
                console.log('Mobile controls initialized successfully');
                
                const cx=30; // Center X
                const cy=30; // Center Y
                const md=25; // Max distance
                let startPos={x:0,y:0};
                
                // Ensure joystick starts inactive
                this.joystickActive=false;
                this.joystickVector={x:0,y:0};

                const hs=e=>{
                    console.log('Joystick touch START');
                    if(!gameState.isRunning || gameState.isPaused) return;
                    e.preventDefault();
                    e.stopPropagation();
                    this.joystickActive=true;
                    const r=jc.getBoundingClientRect();
                    const t=e.touches?e.touches[0]:e;
                    startPos.x=t.clientX-r.left;
                    startPos.y=t.clientY-r.top;
                    jc.style.opacity='1';
                    this.startJoystickMovement();
                };

                const hm=e=>{
                    if(!this.joystickActive) return;
                    e.preventDefault();
                    e.stopPropagation();
                    const r=jc.getBoundingClientRect();
                    const t=e.touches?e.touches[0]:e;
                    const x=t.clientX-r.left-cx;
                    const y=t.clientY-r.top-cy;
                    const d=Math.sqrt(x*x+y*y);
                    let fx=x, fy=y;
                    if(d>md){
                        const a=Math.atan2(y,x);
                        fx=Math.cos(a)*md;
                        fy=Math.sin(a)*md;
                    }
                    js.style.transform=`translate(calc(-50% + ${fx}px), calc(-50% + ${fy}px))`;
                    this.joystickVector={x:fx/md,y:fy/md};
                    console.log('Joystick vector:', this.joystickVector);
                };

                const he=e=>{
                    console.log('Joystick touch END');
                    e.preventDefault();
                    e.stopPropagation();
                    this.joystickActive=false;
                    js.style.transform='translate(-50%,-50%)';
                    jc.style.opacity='.8';
                    this.joystickVector={x:0,y:0};
                    this.stopJoystickMovement();
                };

                jc.addEventListener('touchstart',hs,{passive:false});
                jc.addEventListener('touchmove',hm,{passive:false});
                jc.addEventListener('touchend',he,{passive:false});
                jc.addEventListener('mousedown',hs);
                document.addEventListener('mousemove',hm);
                document.addEventListener('mouseup',he);

                // Jump button
                const bp=e=>{e.preventDefault();e.stopPropagation()};
                ['click','touchend'].forEach(evt=>{
                    jumpBtn.addEventListener(evt,(e)=>{
                        bp(e);
                        console.log('Jump button pressed');
                        if(!gameState.isRunning || gameState.isPaused) return;
                        player.jump();
                    },{passive:false});
                });
            }
            
            startJoystickMovement(){
                if(this.moveInterval)clearInterval(this.moveInterval);
                this.moveInterval=setInterval(()=>{
                    // STRICT CHECK: Only move if joystick is active AND vector exists AND has significant X movement
                    if(!this.joystickActive) return;
                    if(!this.joystickVector) return;
                    if(!gameState.isRunning || gameState.isPaused) return;
                    
                    const threshold = 0.15; // Require at least 15% movement
                    if(Math.abs(this.joystickVector.x) > threshold){
                        const baseSpeed = CONFIG.player.moveSpeed;
                        let mx = this.joystickVector.x * baseSpeed;
                        
                        if(mx < -1){
                            player.moveLeft();
                        } else if(mx > 1){
                            player.moveRight();
                        }
                    }
                },50);
            }
            
            stopJoystickMovement(){
                if(this.moveInterval){
                    clearInterval(this.moveInterval);
                    this.moveInterval=null;
                }
            }
            
            setupTouch() {
                // Disable swipe controls - we have joystick and button now
                // Only prevent context menu
                game.container.addEventListener('contextmenu', (e) => e.preventDefault());
            }
        }

        // =====================================================
        // MAIN GAME CLASS
        // =====================================================
        class Game {
            constructor() {
                this.container = document.getElementById('gameContainer');
                this.containerWidth = 0;
                this.containerHeight = 0;
                
                this.obstacles = [];
                this.spawnTimers = {
                    building: 0,
                    enemy: 0,
                    collectible: 0
                };
                
                this.ui = {
                    score: document.getElementById('scoreValue'),
                    lives: document.getElementById('livesValue'),
                    wave: document.getElementById('waveValue'),
                    progress: document.getElementById('progressFill'),
                    pauseMenu: document.getElementById('pauseMenu'),
                    pauseIndicator: document.getElementById('pauseIndicator'),
                    controlsMenu: document.getElementById('controlsMenu'),
                    gameOver: document.getElementById('gameOver'),
                    waveIndicator: document.getElementById('waveIndicator'),
                    startScreen: document.getElementById('startScreen')
                };
                
                this.updateDimensions();
                window.addEventListener('resize', () => this.updateDimensions());
            }
            
            updateDimensions() {
                const rect = this.container.getBoundingClientRect();
                this.containerWidth = rect.width;
                this.containerHeight = rect.height;
            }
            
            start() {
                gameState.reset();
                player.reset();
                this.clearObstacles();
                this.spawnTimers = { building: 0, enemy: 0, collectible: 0 };
                
                gameState.isRunning = true;
                gameState.isPaused = false;
                
                this.ui.gameOver.style.display = 'none';
                this.ui.pauseMenu.style.display = 'none';
                this.ui.controlsMenu.style.display = 'none';
                this.ui.pauseIndicator.style.display = 'none';
                this.ui.startScreen.style.display = 'none';
                
                this.updateUI();
                this.loop();
            }
            
            startFromMenu() {
                this.start();
            }
            
            showControlsFromStart() {
                this.ui.startScreen.style.display = 'none';
                this.ui.controlsMenu.style.display = 'block';
            }
            
            hideControlsToStart() {
                this.ui.controlsMenu.style.display = 'none';
                this.ui.startScreen.style.display = 'block';
            }
            
            restart() {
                this.start();
            }
            
            togglePause() {
                gameState.isPaused = !gameState.isPaused;
                
                if (gameState.isPaused) {
                    this.ui.pauseMenu.style.display = 'block';
                    this.ui.pauseIndicator.style.display = 'block';
                } else {
                    this.ui.pauseMenu.style.display = 'none';
                    this.ui.pauseIndicator.style.display = 'none';
                    this.ui.controlsMenu.style.display = 'none';
                    if (gameState.isRunning) this.loop();
                }
            }
            
            showControls() {
                this.ui.pauseMenu.style.display = 'none';
                this.ui.controlsMenu.style.display = 'block';
            }
            
            hideControls() {
                this.ui.controlsMenu.style.display = 'none';
                if (gameState.isRunning) {
                    this.ui.pauseMenu.style.display = 'block';
                } else {
                    this.ui.startScreen.style.display = 'block';
                }
            }
            
            showControlsFromStart() {
                this.ui.startScreen.style.display = 'none';
                this.ui.controlsMenu.style.display = 'block';
            }
            
            hideControlsToStart() {
                this.ui.controlsMenu.style.display = 'none';
                this.ui.startScreen.style.display = 'block';
            }
            
            showWaveIndicator() {
                this.ui.waveIndicator.textContent = `WAVE ${gameState.wave}`;
                this.ui.waveIndicator.style.display = 'block';
                
                setTimeout(() => {
                    this.ui.waveIndicator.style.display = 'none';
                }, 2000);
            }
            
            loop() {
                if (!gameState.isRunning || gameState.isPaused) return;
                
                gameState.frameCount++;
                
                // Handle input
                inputHandler.handleContinuousInput();
                
                // Update player
                player.update();
                
                // Spawn obstacles
                this.spawnObstacles();
                
                // Update obstacles
                this.updateObstacles();
                
                // Check collisions
                this.checkCollisions();
                
                // Update UI
                this.updateUI();
                
                requestAnimationFrame(() => this.loop());
            }
            
            spawnObstacles() {
                // Spawn buildings
                this.spawnTimers.building++;
                const buildingRate = Math.floor(
                    CONFIG.spawn.buildingMax - 
                    (gameState.wave - 1) * 15
                );
                const adjustedBuildingRate = Math.max(CONFIG.spawn.buildingMin, buildingRate);
                
                if (this.spawnTimers.building >= adjustedBuildingRate) {
                    this.obstacles.push(new Obstacle('building', { class: 'building' }));
                    this.spawnTimers.building = 0;
                }
                
                // Spawn enemies
                this.spawnTimers.enemy++;
                const enemyRate = Math.floor(
                    CONFIG.spawn.enemyMax - 
                    (gameState.wave - 1) * 10
                );
                const adjustedEnemyRate = Math.max(CONFIG.spawn.enemyMin, enemyRate);
                
                if (this.spawnTimers.enemy >= adjustedEnemyRate) {
                    const enemyConfig = CONFIG.enemies[
                        Math.floor(Math.random() * CONFIG.enemies.length)
                    ];
                    this.obstacles.push(new Obstacle('enemy', enemyConfig));
                    this.spawnTimers.enemy = 0;
                }
                
                // Spawn collectibles
                this.spawnTimers.collectible++;
                if (this.spawnTimers.collectible >= CONFIG.spawn.collectibleMin + 
                    Math.random() * (CONFIG.spawn.collectibleMax - CONFIG.spawn.collectibleMin)) {
                    const collectibleConfig = CONFIG.collectibles[
                        Math.floor(Math.random() * CONFIG.collectibles.length)
                    ];
                    this.obstacles.push(new Obstacle('collectible', collectibleConfig));
                    this.spawnTimers.collectible = 0;
                }
                
                // Spawn boss
                if (gameState.wave >= CONFIG.game.bossWave && 
                    gameState.frameCount % 600 === 0) {
                    this.obstacles.push(new Obstacle('enemy', {
                        class: 'boss',
                        name: 'All-Hands Meeting',
                        damage: 2,
                        points: 500
                    }));
                }
            }
            
            updateObstacles() {
                this.obstacles = this.obstacles.filter(obstacle => obstacle.update());
            }
            
            checkCollisions() {
                const playerBounds = player.getBounds();
                
                this.obstacles.forEach((obstacle, index) => {
                    if (!obstacle.active) return;
                    
                    const obstacleBounds = obstacle.getBounds();
                    
                    // Check collision
                    if (this.isColliding(playerBounds, obstacleBounds)) {
                        // Debug logging for ALL collisions
                        console.log('Collision detected:', {
                            obstacleType: obstacle.type,
                            obstacleClass: obstacle.config.class,
                            playerY: player.y,
                            playerOnGround: player.isOnGround,
                            isDucking: player.isDucking,
                            playerBounds: playerBounds,
                            obstacleBounds: obstacleBounds
                        });
                        
                        if (obstacle.type === 'collectible') {
                            // Collect item
                            gameState.addScore(obstacle.config.points);
                            particles.createBurst(
                                player.x + CONFIG.player.width / 2,
                                player.y + CONFIG.player.height / 2,
                                'collect'
                            );
                            player.celebrate();
                            obstacle.destroy();
                        } else if (obstacle.type === 'building') {
                            // Buildings only hurt if you're on the ground
                            if (player.isOnGround) {
                                if (!gameState.isInvulnerable) {
                                    const gameOver = gameState.loseLife();
                                    particles.createBurst(
                                        player.x + CONFIG.player.width / 2,
                                        player.y + CONFIG.player.height / 2,
                                        'hit'
                                    );
                                    player.takeDamage();
                                    this.updateUI();
                                    
                                    if (gameOver) {
                                        this.endGame();
                                    }
                                }
                                obstacle.destroy();
                            }
                            // If jumping, you clear the building - no damage, no destroy
                        } else {
                            // Enemy collision
                            if (!gameState.isInvulnerable) {
                                const gameOver = gameState.loseLife();
                                particles.createBurst(
                                    player.x + CONFIG.player.width / 2,
                                    player.y + CONFIG.player.height / 2,
                                    'hit'
                                );
                                player.takeDamage();
                                this.updateUI();
                                
                                if (gameOver) {
                                    this.endGame();
                                }
                            }
                            obstacle.destroy();
                        }
                    }
                });
            }
            
            isColliding(rect1, rect2) {
                return rect1.left < rect2.right &&
                       rect1.right > rect2.left &&
                       rect1.top > rect2.bottom &&
                       rect1.bottom < rect2.top;
            }
            
            endGame() {
                gameState.isRunning = false;
                player.die();
                
                document.getElementById('finalScore').textContent = gameState.score;
                document.getElementById('finalWave').textContent = gameState.wave;
                
                const highScoreDisplay = document.getElementById('highScoreDisplay');
                if (gameState.score >= gameState.highScore) {
                    highScoreDisplay.innerHTML = '<strong>üèÜ NEW HIGH SCORE! üèÜ</strong>';
                } else {
                    highScoreDisplay.innerHTML = `<strong>High Score:</strong> ${gameState.highScore}`;
                }
                
                this.ui.gameOver.style.display = 'block';
            }
            
            clearObstacles() {
                this.obstacles.forEach(obstacle => obstacle.destroy());
                this.obstacles = [];
                
                // Clear any remaining obstacle elements
                const remainingObstacles = this.container.querySelectorAll('.obstacle');
                remainingObstacles.forEach(el => el.remove());
            }
            
            updateUI() {
                this.ui.score.textContent = gameState.score;
                this.ui.wave.textContent = gameState.wave;
                
                // Update lives
                const hearts = '‚ù§Ô∏è'.repeat(Math.max(0, gameState.lives));
                const broken = 'üíî'.repeat(Math.max(0, CONFIG.game.startLives - gameState.lives));
                this.ui.lives.textContent = hearts + broken;
                
                // Update progress bar
                const progress = (gameState.score % CONFIG.game.waveScoreThreshold) / 
                                CONFIG.game.waveScoreThreshold * 100;
                this.ui.progress.style.width = progress + '%';
            }
        }

        // =====================================================
        // INITIALIZE GAME
        // =====================================================
        const gameState = new GameState();
        const player = new Player();
        const particles = new ParticleSystem();
        const game = new Game();
        const inputHandler = new InputHandler();

        // Auto-start when page loads
        window.addEventListener('load', () => {
            // Display high score on start screen
            const highScore = gameState.highScore;
            const highScoreEl = document.getElementById('startHighScore');
            if (highScore > 0) {
                highScoreEl.innerHTML = `<strong style="color: #ffd700;">High Score: ${highScore}</strong>`;
            } else {
                highScoreEl.innerHTML = '<strong>Ready to escape the 9-to-5?</strong>';
            }
            
            // Re-initialize mobile controls after page load to ensure elements exist
            setTimeout(() => {
                console.log('Re-initializing mobile controls after load');
                inputHandler.setupMobile();
            }, 500);
        });
    </script>
</body>
</html>
